%%*******************************************************************************************************************************
\def\baselinestretch{1.66}
%%*******************************************************************************************************************************
%\pagestyle{fancyplain}
%********************************************************************************************************************************
\chapter{多分辨率控制器的FPGA硬件加速实现}
%%*******************************************************************************************************************************
\fancyhf{}  %清除以前对页眉页脚的设置
\fancyhead[CE]{\color{black}\xiaowuhao\CJKfamily{kai}吉林大学硕士学位论文} \fancyfoot[LE]{\thepage}    % 在book 文件类别下,
\fancyhead[CO]{\color{black}\xiaowuhao\CJKfamily{kai}\leftmark} \fancyfoot[RO]{\thepage}     % \leftmark 自动存录各章之章名,
%********************************************************************************************************************************
\setlength{\abovedisplayskip}{2pt plus5pt minus1pt}     %公式前的距离
\setlength{\belowdisplayskip}{2pt plus5pt minus1pt}
%%*******************************************************************************************************************************
基于ESL思想的高层次综合技术（High Level Synthesis, HLS）在近几年的~FPGA~开发过程中就得到很大的发展，综合（Synthesis）是指定义成两种不同的设计描述之间的转换，把各种设计要求作为一种约束条件加以设计，综合器将通过各种综合算法实现优化设计~\textsuperscript{\cite{damak2011fast}}。而~HLS~是指将行为级或者更高层次的描述转化为~RTL~ 级别的描述，目前一般是将~C~ 语言或者其衍生语言或者更高层次描述语言如~MATLAB~语言转到硬件语言~Verilog~或~VHDL。目前常见的~HLS~工具就有 明导国际 (Mentor Graphics) 的 ~Catapult C~ 合成工具，其主要支持将~C/C++~语言转换成~Verilog~语言或~VHDL~ 语言，该工具转换效率高，一般最终生成代码的质量较高，但转换时间较长；全球电子设计自动化（EDA）软件工具的主导企业~Synopsys~ 推出了自己的 ~Synphony C Compiler~也壮大了~HLS~工具的阵营；而美国~MathWorks~ 公司和~FPGA~ 厂商合作开发的~HDL coder~工具也为~MATLAB~ 工具使用者提供了算法快速实现的捷径，其支持将特定的~Matlab~ 语言和~Simulink~模型转换为硬件语言；而自从~Xilinx~公司推出~Vivado HLS~ 工具后，~HLS~工具在硬件设计领域就越发流行和重要，其支持将~C/C++/System C~代码转换成~Verilog~ 或~VHDL~ 语言，由于~Xilinx~公司自身~FPGA~器件制造商的身份，其产品更能适应自身器件，其综合生成的硬件代码与~FPGA~ 器件契合度非常高，优化的空间也很大，综合报告的内容更为丰富，这也方便用户自主作进一步的优化。一般来说用~Vivado HLS~ 工具对~Xilinx~公司生产的~FPGA~ 进行开发效率会更高，综合出来的代码质量更好等。故上述高级综合工具的出现和发展，使得~FPGA~ 开发不再是硬件工程师的天下，众多软件工程师也能参与到~FPGA~ 的开发上。相对于硬件的设计和开发，软件环境下有更广泛的资源，更全面的开源算法库（如深度学习~caffe~ 库、计算机视觉~OpenCV~ 库等）以及更加庞大的开发人员团队，使基于~FPGA~ 的开发人员得到很大的提升，让~FPGA~ 能应用到更多的场合，如果将手工硬件设计的复杂度用~HLS~ 工具屏蔽掉的话，就能加速FPGA 的开发，提升开发效率~\textsuperscript{\cite{Lu2014ZYNQ}}。需要注意的是，~HLS~ 技术也不是开发~FPGA~一劳永逸的方法，在某些对“面积”和“速度”精确要求的场合，传统的手工RTL 方法会让后期调试更加方便，而且在一些信号接口领域，使用手工~RTL~ 方法会使设计更加方便，故需要在具体的设计中合理取舍开发工具~\textsuperscript{\cite{gajski2012high}}。

一般情况下，控制算法需要有较强的实时性，故可以采取~FPGA~进行控制算法的加速，针对前文中多分辨率PID 控制算法和多尺度~MP~C控制算法都是在~MATLAB~中完成，目前~MATLAB~中的~HDL coder~ 工具还不太完善，而且无法针对~MATLAB~中的~Interpreted MATLAB Function~编写的控制算法作出有效的转换~\textsuperscript{\cite{simulinkcoder}}，故本设计采取~Xilinx~的~Vivado HLS~方案进行控制算法的~FPGA~实现。
%********************************************************************************************************************************
\section{控制算法的~FPGA~实现方案}
%********************************************************************************************************************************
一般来说，用~FPGA~来进行控制算法的加速开发包含如图~\ref{fig5:5:development_process}~所示的流程，实际上针对其他算法的~FPGA~ 开发验证都基本适用，下面就具体多分辨率PID控制器的开发实现作详细说明。
\begin{figure}[htb]
\centering
\includegraphics[width=15cm]{ch5/development_process.eps}
\caption{基于FPGA的控制算法实现流程图} \label{fig5:5:development_process}
\end{figure}

\vspace{15pt} \hspace{-28pt} {\bf （1）控制算法设计}

首先在~MATLAB~中完成控制算法的设计及验证，一般来说，在控制器的前期设计中，MATLAB~是个非常有效的工具，其包含各种工具箱和库函数以提高控制算法的设计效率，如在多尺度PID控制算法的设计过程中即使用了小波多层分解函数“wavedec”，小波单层重构函数“idwt”等，多尺度MPC控制器设计中使用“quadprog” 函数求解QP问题等，而且~MATLAB~便捷的在线调试功能和实时数据显示功能都能为控制算法的前期设计及验证提供了良好快捷的平台；在利用~MATLAB~完成控制算法的设计及验证后，通过分析控制算法的结构特点进行算法的模块划分，将适用于用硬件语言描述的部分划分出来，一般情况下控制器的结构中输入输出的接口部分适合直接用硬件语言描述，而算法主体部分适合用高级语言C/C++ 进行表示。

\vspace{15pt} \hspace{-28pt} {\bf （2）控制算法C/C++代码化}

由于Vivado HLS不支持将~MATLAB~中的~m~语言直接转为硬件语言，故需要将基于~m~语言的控制算法转为更加广泛出现的C/C++语言。在用C/C++ 语言来表示控制算法的主体部分时，m~ 语言中直接的矩阵运算、高级操作、工具箱函数等在~C/C++ 语言中并不存在，特别是工具箱函数是否能代码化将会直接影响到后续设计的成功性，如小波分解函数和小波重构函数都是可以通过卷积运算中的乘加运算完成、多尺度MPC 的QP 求解函数可以用牛顿迭代法实现等等。在将控制算法~C/C++~ 代码化后，需要验证代码的正确性。一般情况下，有两种验证方法：开环测试，如图\ref{fig5:1:C_Va} 所示，将MATLAB 中的控制器的输入数据作测试激励，测试~C/C++~ 控制器的输出实验数据与原MATLAB中的控制器数据是否吻合；第二种方法如图\ref{fig5:1:C_Vb} 利用~MATLAB~ 中的~S-function Builder~ 工具（不支持C++），将完成的C 代码嵌入其中，这样就可以在~MATLAB~ 中用~C~ 代码实现的控制器来控制被控对象，完成控制器的闭环验证。
\begin{figure}
  \centering
  \subfigure[算法开环验证]{
    \label{fig5:1:C_Va} %% label for first subfigure
    \includegraphics[width=6cm]{ch5/C_vertify1.eps}}
  \hspace{1in}
  \subfigure[算法闭环验证]{
    \label{fig5:1:C_Vb} %% label for second subfigure
    \includegraphics[width=6cm]{ch5/C_vertify.eps}}
  \caption{控制器代码化验证}
  \label{fig5:1:C_vertify} %% label for entire figure
\end{figure}

\vspace{15pt} \hspace{-28pt} {\bf （3）控制算法C/C++代码定点化}

FPGA~的资源结构就意味着对于浮点运算，定点运算更有效率和更省资源，故为了减小控制算法的运算量，减少~FPGA~资源的消耗，故需要将设计好的~C/C++~控制算法进行定点转换。在~Vivado HLS~自身的安装文件下有关于将浮点数据转换成定点数据的头文件，可以利用头文件中的定点数据设计模板完成控制器中每个数据量的定点化，其设计的目标为定点的数据要满足数据的大小范围，而且在保障数据的精度情况下尽可能减小数据位宽以提高运算速度和硬件资源的占用。

\vspace{15pt} \hspace{-28pt} {\bf （4）Vivado HLS 综合}

在完成定点控制算法后，就可以将代码进行综合，Vivado HLS会自动将定点的C/C++代码转换成HDL代码，由于软件语言和硬件语言天然上的差异性，在代码转换中，可以个人添加一些优化命令，如接口握手信号、时钟运行频率、设计目标、软件代码并行展开、数据特定存储等约束，这样综合出来的代码会更有效率。在~FPGA~设计中，往往存在着“空间（FPGA资源占用）”和“时间（算法的延迟）”的相互博弈，这就需要在具体设计中，不断进行调试，以达到目标要求。在完成~HDL~代码的生成后，为了验证转换得到的~HDL~代码的正确性，就可以联合~ModelSim~工具进行功能仿真。ModelSim 由 Mentor Graphic 公司的子公司 Model Tech 公司推出，是业界最优秀的硬件描述语言仿真软件。

\vspace{15pt} \hspace{-28pt} {\bf （5）RTL综合/布局/布线}

结合接口代码和生成的算法~RTL~代码，就可以利用~Xilinx~官方工具~Vivado~进行代码的~RTL~综合，Vivado 能按照时序约束将~RTL~代码自动进行综合然后进行布局布线，然后生成~FPGA~配置文件。最终可以将配置文件下载到~FPGA~中完成控制器的硬件实现，为了验证控制器的正确性，需要对被控对象进行闭环控制等。
%********************************************************************************************************************************
%***********************************************************************************************************************************
\section{控制器的算法结构和并行性分析}
%***********************************************************************************************************************************
传统~PID~能广泛应用到实际工业生产中，除了其结构简单易于理解和上手外，其计算量还特别小，计算负担低，所以人们不需要担忧其实时性问题。所以针对多分辨率~PID~控制算法来说，对其进行硬件实现及运算复杂度分析在实际应用中有着重要的意义，多分辨率小波控制器是基于小波变换而来的，故其有着很好的计算复杂度。通过分析前文中多分辨率小波控制器的结构，可以发现在利用~Mallat~ 算法对信号进行二通道滤波器组进行滤波时存在硬件上的优化地方。

首先是输入信号的对称数据缓存窗的结构，这种数据缓存结构就是硬件上先入先出缓存器（FIFO），此种数据结构在硬件上的存取速度很快，只需一个时钟周期就能完成读取操作。

然后在~Mallat~算法中，对信号进行多分辨率分解其实就是将滤波器系数组成的固定序列和输入信号序列做卷积运算。针对~db2~小波来说，运算过程如图~\ref{fig2:13:mallat_chart}~所示，其中上面四个数即为四个低通滤波器系数组成的序列，下面一排即为信号序列，其中虚线框内的信号值即为周期对称延拓后所添加的信号，其与滤波器序列进行乘加运算，即可得到一层小波分解的一个中间值，然后滤波器序列一一平移然后做乘加运算即可最终得到一层小波分解的所有中间值。在下一个时刻，相同的数据以先入先出的方式进入数据窗结构，之后做相同的乘加操作，所以可以发现在每个时间周期，由于只更新两个数据，所以不需要将数据窗内的每个数据都和滤波器序列进行相乘，我们可以“借助”上一个时刻的乘法结果，在新的时刻只需要将新的数据值分别与四个滤波器参数进行相乘即可，这样就能大大提高每个时钟周期的计算速率。当然这样做的代价就需要利用更多的存储器来存储上一个时钟周期的乘积值，但是其能很大程度节省乘法器资源，特别是当数据窗里的数据比较多时，这种节省是可观的，而且在硬件中，乘法运算是比较耗时且耗资源的，故采用这种方法能很大程度节省计算时间。
\begin{figure}[htb]
\centering
\includegraphics[width=15cm]{ch2/mallat_op.eps}
\caption{Mallat算法运算流程图} \label{fig2:13:mallat_chart}
\end{figure}

最后可以发现小波分解过程中，信号序列和小波高通滤波器序列与小波低通滤波器序列进行卷积运算时是相互独立的，故可以进行并行运算。而在小波综合过程中，每个分辨率的信号分量均是独立运算得到的，无相互干扰，故也可以进行并行运算，其并行运算结构如图~\ref{fig2:14:pall}。
\begin{figure}[htb]
\centering
\includegraphics[width=15cm]{ch2/mallat_pall.eps}
\caption{Mallat算法中并行结构示意图} \label{fig2:14:pall}
\end{figure}
经过上述分析可知，虽然~MSPID~控制器相对于传统~PID~控制器算法复杂一些，但是由于小波分解中的~Mallat~算法可以进行并行加速，实际上到了硬件实现阶段，MSPID~控制算法也能很快的完成运算，以应用到快速实时系统的，后文中将会对~MSPID~控制算法的~FPGA~硬件加速实现过程进行详细说明分析，并最终用于实物的直流有刷电机控制上。

%***********************************************************************************************************************************
\section{多分辨率~PID~控制器的~FPGA~硬件实现}
%***********************************************************************************************************************************

\subsection{定点数据设计}
%********************************************************************************************************************************
按照上节的开发流程，在第二章中的多分辨率PID控制器设计中，已完成控制器的~C/C++~代码设计，并通过S-function Builder工具验证了~C~控制器的正确性，故需要进行定点数据设计，在Vivado HLS 中有关于整数和小数的定点模板，分别为~$ap\_[u]int<W>$~和~$ap\_[u]fixed<W,I,Q,O,N>$，模板中参数的具体意义如下~\textsuperscript{\cite{UG902}}：

~$[u]$~意味着所设计的数据是否有符号，添加~$u$~则为无符号，如~$ap\_uint<W>$~意味着无符号的整型定点数；

$W$：数据的总位宽；

$I$：在进行定点小数设计过程中设计，其代表整数位位宽；

$Q$：量化模式，指的是定点小数相对于浮点小数精度丢失的设置方法，常见的有~$AP\_RND\_CONV$，其代表四舍五入到最近的值，$AP\_RND\_ZERO$~代表的是四舍五入到零，$AP\_TRN\_ZERO$~则为默认的截断到零等等；

$O$：溢出模式，指的是当设计的定点数据所能达到的最大值仍小于要表示的浮点数时，所设置的处理方式。常见的有~$AP\_SAT$，其代表饱和状态，即以其能表示的最大的数来代替该浮点数，$AP\_SAT\_ZERO $~代表着饱和到零，当要表示的浮点数据大于设计的定点数据所能达到的最大值时，即用零来表示该浮点数，$AP\_WRAP$~则为默认设置的回卷模式的四舍五入方式等等。

$N$:代表回卷模式下的饱和位数，一般情况下该位可以不用设计。

通过上面的模板的具体意义可以看得出来，针对浮点数据的定点化，就是确定模板中各个参数的过程。在设计中，对于浮点整数的参数确定就很简单，其只需要确定数的位宽以保证所设计的定点数不会溢出即可；而针对浮点小数的定点化过程，相对就会复杂一些，其主要注重的就是数据的总位宽~W~ 和整数位宽~$I$~, 总位宽~$W$~和整数位宽~$I$~决定一个定点小数的设计质量，其设计属性如表~\ref{tb5:1:fix}~所示。我们的设计目标就是所设计的定点小数能尽可能还原浮点小数，即在不溢出的情况下保证一定的小数精度，定点小数不像定点整数，其一定会造成数据精度丢失，只有在小数位宽足够时，这种影响才会削弱，故在定点整数设计过程中需要进行反复验证，以保证最终的数据结果满足系统要求；而定点小数设计时的量化模式~$Q$~和溢出模式~$O$~对算法的计算的性能有一定的影响，在总位宽和整数位宽设置得当的情况下，这两个参数可以选择默认的直接截断到零的量化模式（$A P\_TRN\_ZERO$）和回卷的四舍五入方式（$AP\_WRAP$），特殊情况下可以选择其他情况，如在调试阶段可将溢出模式设置为饱和到零（$AP\_SAT\_ZERO$）的设置，这样就能更方便的定位到具体哪个变量出现溢出的现象。

\begin{table}[hbt]
\begin{center}
\caption{ Vivado HLS~定点数据模板}\label{tb5:1:fix}
\begin{tabular}{c||c||c}
\hline\hline
 数据类型                & 范围                      & 精度\\
 \hline
 $ap\_uint<W>$          &0 $\sim$ $2^W-1$                   & 1      \\
  \hline
 $ap\_int<W>$           &$-2^{W-1}$ $\sim$ $2^{W-1}-1$         &1           \\
  \hline
 $ap\_ufixed<W,I>$      &0 $\sim$ $2^I-2^{I-W}$              &$2^{I-W}$        \\
  \hline
 $ap\_fixed<W,I>$        &$-2^{I-1}$ $\sim$ $2^{I-1}-2^{I-W}$   &$2^{I-W}$  \\
\hline\hline
\end{tabular}
\end{center}
\end{table}

故在设计定点小数的时候，需要确定原数据的数据范围，这样就能决定数据模板中的整数位位宽I的具体数值，而在~$I$~值确定的情况下总体位宽~$W$~值的大小就确定小数的精度，在多分辨率~PID~控制算法中，数据变量不是很多，故可以逐个确定每个变量的取值范围。在控制器中部分变量的定点数据类型设计如下：
\begin{table}[hbt]
\begin{center}
\caption{部分数据的定点设计示例}\label{tb:2:fixed}
\begin{tabular}{c||c||c}
\hline\hline
    变量     & 数据大致范围     & 定点设计 \\
\hline
 输入偏差          & [-2,2]        & $ap\_fixed<24,3>$       \\
  \hline
小波分解中间变量           & [-4,4]     &$ap\_fixed<28,4>$               \\
 \hline
 小波分解中间量长度      & [1,12]   &$ap\_uint<4>$                  \\
  \hline
控制器输出量          &[-1,1]	&$ap\_fixed<20,1>$	    \\
\hline\hline
\end{tabular}
\end{center}
\end{table}


在完成控制算法中所有数据的定点设计后，需要验证设计定点数据是否满足要求，此时可以在Visual Studio 环境下分别测试相同的偏差输入下，定点控制器和浮点控制器的结果偏差。通过验证，可以得出图~\ref{fig5:2:fixed_float}~的结果。通过曲线可以看出定点算法输出和浮点算法输出曲线几乎完全重合，偏差特别小，其数量级在~$10^{-4}$~，说明设计的定点控制器是符合要求的。完成定点设计后，就可以通过~Vivado HLS~ 工具对定点~C/C++~代码进行转换生成~HDL~语言。
\begin{figure}[htb]
\centering
\includegraphics[width=15cm]{ch5/fixed_float.eps}
\caption{定点数据设计结果} \label{fig5:2:fixed_float}
\end{figure}
%********************************************************************************************************************************
\subsection{综合优化}
%********************************************************************************************************************************
在第三章分析了多分辨率~PID~控制器的算法结构，得出控制算法有多种优化结构的结论。在~Vivado HLS~ 综合过程中，优化设置的不同对最终综合结果有很大的影响，好的优化设置能同时减小~FPGA~资源的占用和控制代码的运算时间~\textsuperscript{\cite{OverviewVivado}}。

\vspace{15pt} \hspace{-28pt} {\bf （1）数据结构优化}

在上节的数据结构设计中，数据的总位宽对最终综合结果影响很大。需要注意的是，在传统~FPGA~结构中，针对算法的乘法结构，FPGA~一般需要大量的查找表资源和加法器构建一个乘法，且需要占用很长的运算时间，而随着FPGA技术的发展，目前~FPGA~一般都内置了专用~DSP~乘法器，其只需要一个时间周期就可以完成乘法运算，但是~FPGA~内部的~DSP~乘法器资源有限，且位宽也是固定的。如~Xilinx ZYBO~板卡中的~DSP~乘法器为25*18规格，数目为80，故当乘数的位宽大于18 时，一个乘法运算就会占用两个乘法器，比较浪费资源，故在设计乘数的位宽时需要主要这种情况；此外，由于数据在FPGA内部存储是以寄存器或ROM/RAM形式存在，而~FPGA~基本组成单元为四路查找表，故在数据设计中的位宽尽量设置为~4、8~等~4的倍数，这样才能充分利用~FPGA~硬件资源才不至于造成资源浪费，这种做法就类似于软件语言里面的内存对齐的概念。

\vspace{15pt} \hspace{-28pt} {\bf （2）代码优化}

硬件资源对加法和减法处理起来十分方便，由于~DSP~乘法器的存在，乘法也可以得到很快的运算，但是对于~MSPID~算法中除法，FPGA~处理起来就很费劲，会浪费掉大量的资源和时间，故需要针对其中的除法，做相应的处理。如果除法的除数为固定值的话，可以用乘以除数的倒数来进行处理，特别地，如果除数为~2 的幂次方或者乘数为~2的幂次方，可以采取移位操作完成乘除运算，此方法最节省时间和资源。如果除数为变量，还可以尝试使用~Xilinx~官方库中存在的~$sdiv$~函数或~$udiv$~函数来完成除法操作，此方法可以将算法中的除法综合成并行或串行的~RTL~除法，节省时间或资源。

\vspace{15pt} \hspace{-28pt} {\bf （3）循环展开}

循环是C/C++语言中一项关键属性，其是一种很典型的串行执行程序，而在Vivado HLS对循环进行的展开操作，也就是一种硬件加速过程。当循环体内部循环之间没有相互关系，就可以将循环完全展开，这是一种并行执行的思想；当循环体内部的循环相互有联系，就可以进行循环平坦化处理，这是一种流水线执行的思想。无论哪种情况，都能完成循环体的硬件加速。在本设计中，小波分解和小波重构函数中包含大量的循环，如图\ref{fig5:5:optimize_a}所示，故在此可以设计循环的展开优化，当然循环的展开的代码最终生成的~HDL~代码会增加~FPGA~的占用资源，这一点可以针对实际情况加以调整，如可以选择部分展开等。
\begin{figure}
  \centering
  \subfigure[循环展开]{
    \label{fig5:5:optimize_a} %% label for first subfigure
    \includegraphics[width=4cm]{ch5/unroll.eps}}
  \hspace{1in}
  \subfigure[数组优化]{
    \label{fig5:5:optimize_b} %% label for second subfigure
    \includegraphics[width=6cm]{ch5/array.eps}}
  \caption{综合优化}
  \label{fig5:5:optimize} %% label for entire figure
\end{figure}

\vspace{15pt} \hspace{-28pt} {\bf （4）存储结构的优化}

和循环一样，在C/C++程序中，数组也是一种直观且有用的软件结构，然而在HDL中，数组的创建和访问如果不处理好，经常会成为其性能上的一个瓶颈。C/C++~语言中的数组经过~Vivado HLS~ 工具综合后，在HDL中的表现形式有多中，如RAM、block RAM、LUTRAM、ROM、FIFO和register （寄存器）等，不同的存储方式对设计的“时间和面积”都有不同的影响。如分析针对数组~fH[N]不同存储结构下（单端口RAM，双端口RAM和寄存器）的读取过程，在单端口RAM存储下，一个时钟周期只能读取一个数组值，双端口~RAM~一个时钟周期能读取两个时钟周期，而设置成寄存器存储的时候在一个时钟周期就能将~fH[N]~ 的所有值读取出来，从而减小了系统的延迟。故在设计时可以采取不同的数据存储的方法针对算法中的数组进行相应处理。在~MRPID~控制算法中，输入的对称数据缓存窗结构就是一个先入先出的结构，故可以设置存储方法为~FIFO~存储，小波滤波器为常数滤波器，可以设置存储方式为ROM，等等，以达到最终生成的~HDL~代码的“速度”和“面积”平衡。

\vspace{15pt} \hspace{-28pt} {\bf （5）并行结构设定}

通过第二章的分析可知：在进行小波分解的时候，分解得到的趋势信号和细节信号的过程是并行的，而在小波重构时，各个分辨率之间的重构是也是完全并行的，故可以在程序优化中加以设置，在程序中添加~$set\_directive\_dataflow$~指令，就可以完成在函数层面上的并行操作，并按照最小延迟进行综合。
%********************************************************************************************************************************
\subsection{HDL代码生成}
%********************************************************************************************************************************
经过上述的优化方案后，就可以得到经定点C控制算法综合出来的HDL代码，并可以通过查看综合报告得到最终HDL代码占用的FPGA板卡资源和运行时间。可以对比在不同的优化方案下最终生成代码的性能。

本次使用的是Xilinx公司生产的Zybo开发板，其是一款Zynq系列的板子，但是在本次实验中，我们不用其ARM 核（PS）部分，而直接用其硬件资源（PL）部分，其内置一款低端的Artix-7系列的~xa7z010~ ~FPGA，硬件资源十分有限。

最终综合调试的结果如表~\ref{tb:3:result}可以看得出来在设置~FPGA时钟频率在~125MHz(即时钟周期为8ns) 的情况下，solution1代表的是代码不作人为的任何优化，完全由工具自行优化综合，solution2 代表的是对代码中循环、数组和并行结构作相应部分优化处理，solution3则是对代码中的所有循环都作展开处理。可以发现三个解决方案都有时序裕量，满足系统的时序要求。而报告中的Latency 则代表着控制器完成一次运算所需要的时钟周期，其代表着控制器的性能。下方的资源消耗估计表则为控制器所需要的~FPGA 内部的各种资源，可以发现控制算法性能越高，其所占FPGA资源也越多，但由于本次试验用的~FPGA 的硬件资源非常有限，故在~solution3 中其时延虽然最小，但是硬件占用也大大超过板卡自带的资源，故不予采用。故本次综合结果采用~solution2的方案，实际上，~solution2 中的优化也是一步一步调试才完成的，算是本次设计的人为优化的最优的方案之一。从~~solution2的时延可以看出，其完成一次控制算法的运算需要的时间为~2668*10ns=0.027ms，可以看出基于FPGA设计的控制器的性能非常高，能够很好的满足控制器实时控制的要求，经过~Vivado HLS~ 综合后的代码可以在工程所在文件下找到，在~Verilog~文件夹下能找到生成的~Verilog~文件和一些数据文件，故可以用这些硬件语言文件来完成控制器的设计。需要注意的是，Vivado HLS工具关于时序、性能和资源的综合报告只是软件大致估计的结果，具体的信息还需要用FPGA开发工具综合完才能确定。

\begin{table}[hbt]
\begin{center}
\caption{不同解决方案综合结果}\label{tb:3:result}
\begin{tabular}{c||c|c|c}
\hline\hline
    解决方案     & solution1     & solution2  & solution3\\
\hline
  时序         & 7.34        & 7.34          &7.34           \\
  \hline
 时延（Latency）   & 3536       &  2668          &1769   \\
 \hline
资源占用           \\
\hline\hline
BRAM\_18K          &6(5\%)	       &6 (5\%)     &24(20\%) \\
\hline
DSP48E          &54(67\%)         &79(98\%)    &167(208\%)\\
\hline
FF               &6223(17\%)      &9325(26\%)  &14324(40\%)\\
\hline
LUT            &9663(54\%)         &11451(65\%) &16395(93\%)\\
\hline\hline
\end{tabular}
\end{center}
\end{table}
%********************************************************************************************************************************
\subsection{功能仿真验证}
%********************************************************************************************************************************
为了验证设计出来的控制器~HDL~代码的正确性，本文利用~HDL~专业仿真软件~ModelSim~对生成的代码进行离线仿真验证，通过编写测试激励，再与控制器软件代码相同的输入下进行仿真，最终得到~ModelSim~ 仿真的波形图如图~\ref{fig5:3:ModelSim} 所示。
\begin{figure}[htb]
\centering
\includegraphics[width=15cm]{ch5/ModelSim.eps}
\caption{控制器~HDL~代码的~ModelSim~仿真结果} \label{fig5:3:ModelSim}
\end{figure}

注意到波形图中的各个信号的变化情况，其中~$ap\_clk$~即为控制器的时钟输入，其周期为~8~ns~，~$ap\_start$~为控制器输入的使能信号，~$ap\_rst$~为控制器输入的复位信号，~$y\_V$~ 为控制器的输入信号，在本设计中为电机的转速信息，~$ap\_return$~为控制器的输出信号，也就是占空比信号，由于这两个数为定点数，故会呈现图中所示的整数，~ $ap\_done$~为控制器的输出信号，代表着控制器完成运算，通过图中的相邻的两个done信号的光标定位可以看出控制器完成运算需要的时间为~15240000ps（0.01524ms）~，即需要的时钟周期的个数为~1905。最终经过控制器~HDL~代码运算的结果输出与~C/C++~代码的对比如图~\ref{fig5:4:VSModelSim}所示，可以发现控制器的~HDL~ 代码与原本软件控制器在相同输入情况下输出偏差非常小。故通过~ModelSim~对~HDL~代码的仿真可以得出此硬件代码描述的~MSPID~控制器的正确性和拥有很好的计算性能。

\begin{figure}[htb]
\centering
\includegraphics[width=15cm]{ch5/VSModelSim.eps}
\caption{~HDL~代码输出} \label{fig5:4:VSModelSim}
\end{figure}
%********************************************************************************************************************************
\section{接口设计}
%********************************************************************************************************************************
在电机的闭环速度控制中，控制器与电机的接口方式主要是控制器需要得到电机的转速信号，此处可以用光电编码器来获取电机转速，然后将控制所得的占空比转为PWM信号作用在电机驱动上。故需要编写光电编码器测速程序和PWM产生程序，此处的接口程序采用Verilog直接编写。
%********************************************************************************************************************************
\subsection{光电编码器测速程序}
%********************************************************************************************************************************
本次采用的光电编码器为长春华特公司生产的高性能增量式光电编码器~E2065AD8~系列，其脉冲数为65536，即可以准确的测量电机在低转速运行状态下的转速值，本次控制的采样周期为1ms，故可以在~FPGA~代码中设置一个定时器和计数器。在~Verilog代码中，定时器和计数器非常容易实现，任意一个门电路都可以作为一个定时器和计数器，这也是其和普通单片机的区别。光电编码器测速程序的ModelSim仿真图如下：
%********************************************************************************************************************************
\subsection{PWM产生程序}
%********************************************************************************************************************************
本次被控对象电机为稀土永磁直流力矩电动机，其具有快速响应，低转速，大力矩，特性线性度好，力矩波动小等特点，而且结构简单，紧凑，是一种高精度伺服系统功率元件。选用的电机驱动器型号是~BRT60A，其中的驱动是(带有MOS管IRLR7843)IRS2184~芯片，该驱动具有较好的抗干扰能力，输入~3.3V和~5V兼容，最大承受的电流是~60A，且能输出正负脉冲的~PWM，其能很好的满足电机的控制需求。一般情况下电机驱动的PWM 频率不宜过高或过低，频率太高，驱动器的开发损失较大，频率过低，电机会出现振动，且电磁噪声也比较明显，故此处采用10KHz的PWM 波对其进行驱动。

PWM 算法FPGA实现流程如图\ref{fig5:3:PWM_chart}所示，其主要原理在于计数器和一个固定的数值duty作比较以输出0 或1。 为了得到频率为10KHz的方波，需要在计数器大于12500 （时钟周期为8ns）时置零，为了得到特定占空比的PWM，可以通过计算duty的值，此处的duty=12500*u，u为MRPID 控制输出的占空比结果，需要注意的是，如果存在电机反向控制，此处的u即为负值，而FPGA输出的负占空比以补码形式存在，需要作相应处理才能得到duty 值。
\begin{figure}[htb]
\centering
\includegraphics[width=15cm]{ch5/PWM_chart.eps}
\caption{PWM 算法FPGA实现流程图} \label{fig5:3:PWM_chart}
\end{figure}
将设计的~PWM~模块进行~ModelSim~仿真，结果如图\ref{fig5:4:PWM_test}所示，算法的PWM输出和周期是正确的，故本次设计的PWM 模块功能是正确的。
\begin{figure}[htb]
\centering
\includegraphics[width=15cm]{ch5/PWM_test.eps}
\caption{PWM 算法ModelSim仿真结果图} \label{fig5:4:PWM_test}
\end{figure}

%********************************************************************************************************************************
\section{板级验证及实物控制}
%********************************************************************************************************************************
在完成了控制器算法的硬件语言生成以及硬件接口的驱动程序后，就可以将所有的硬件代码放到Xilinx~官方的FPGA开发工具~Vivado~中进行综合布局布线，然后生成~FPGA~的配置文件即完成控制器的设计~\textsuperscript{\cite{UG893}}。

通过RTL综合视图可以发现控制器的总体电路结构如图~\ref{fig5:5:RTL}所示，其和设计的控制器相同，主要是由两个接口结构和一个控制算法结构组成，经综合后~FPGA~的资源报告如图\ref{fig5:6:utilization} 所示，可以发现~MSPID~控制算法所占的硬件资源在所选的~Zybo板卡下的表现。其中~LUT~ 即为查找表资源，主要负责控制器的逻辑变换和存储等，这一部分资源占用~$26\%$；~FF~为触发器资源，主要负责算法中的时序，控制器占用~$23\%$；LUTRAM和BRAM为一些存储单元，主要负责算法中的数据存储，这一部分资源消耗较少，主要是因为算法里面的矩阵较少，数据也不多；而~DSP~ 资源则是负责算法中的乘法运算的快速实现，这一部分由于前面的优化消耗较多，占用整个板卡的~$90\%$，这一方面也是由于此板卡较为低端，DSP 资源非常少，另一方面也在于算法中存在不少的乘法运算的缘故，故此处占用过多。综合看来，可以发现本次设计的~MSPID~控制器的硬件消耗并不算太多，所选的FPGA板卡满足其要求，而且控制器在FPGA的硬件并行加速下，具有非常优异的性能。
\begin{figure}[htb]
\centering
\includegraphics[width=15cm]{ch5/schematic.eps}
\caption{控制器的~RTL~视图} \label{fig5:5:RTL}
\end{figure}

\begin{figure}[htb]
\centering
\includegraphics[width=12cm]{ch5/utilization.eps}
\caption{控制器的FPGA的资源占用} \label{fig5:6:utilization}
\end{figure}


\newpage
\thispagestyle{empty}
\cleardoublepage
